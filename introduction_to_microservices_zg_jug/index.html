<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Microservices Architecture</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="microservices.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="architektura-mikroserwisow">Architektura Mikroserwis&#xF3;w</h1><img src="images/slides/00.good_bad_and_ugly.jpg" class="main-picture"></img><h1 id="dobry-zly-i-brzydki">Dobry, z&#x142;y i brzydki</h1><div class="notes"><p>Start!!!</p></div></div><div class="step step-level-1" step="1" data-x="0" data-y="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><h1 id="robert-firek">Robert Firek</h1><p>@RobertFirek</p><img src="images/codurance.png" class="codurance-logo"></img><div class="notes"><p>Zawsze chcia&#x142;em zosta&#x107; architektem, a zosta&#x142;em rzemie&#x15B;lnikiem ;)
Je&#x15B;li kto&#x15B; chce poj&#x15B;&#x107; w moje &#x15B;lady to zatrudniamy. Po szczeg&#xF3;&#x142;y zapraszam po prezentacji.</p><p>[Mala sprawa organizacyjna. Jesli ktos ma jakies pytanie podczas prezentacji to prosze mi przerwac i od razu pytac.
Jak odpowiedz bedzie za dluga lub skomplikowana to przesuniemy odpowiedz na przerwe]</p></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/00.ugly.jpg" class="good-bad-ugly black-border"></img><div class="notes"><p>brzydkiego.</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/01.Monolith.png"></img><div class="notes"><p>Oto Monolit. Ten obraz mam przed oczami kiedy czlowiek opowiada o swojej aplikacji jako aplikacji monolitycznej.</p><p>Ciemna masa kodu, ktora jawi sie na zewnatrz jaka ciemna masa biznesowych opcji. Straszna niepoznana przestrzen.</p><p>Co dziwne takie podejscie jest nadal popularne i nie ma za miaru sie wycofywac. Wiekszosc z nas nadal pewnie
pracuje w takim modelu i jakos wszyscy zyjemy. I malo tego sa to projekty, ktore odnosza sukcesy, a ludzie
sa szczesliwi, ze moga w nich pracowac.</p><p>Dlaczego powstala wiec alternatywa w stosunku do takiej architektury.</p><p>Zanim odpowiemy na to pytanie przyjrzyjmy sie najpierw czym tak naprawde jest ten MONOLIT.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/02.Monolith_insides.png"></img><div class="notes"><p>Jesli spojrzec glebiej w monolit to okazuje sie ze taki monolityczne to juz on nie jest.</p><p>W koncu nasza aplikacja musi eksponowac jakos swoje mozliwosci swiatu i wewnetrznie tez musi miec jakis wewnetrzny
model.</p><p>I nie musi to byc swiat monolityczny. Kazdy element w ukladance naszej aplikacji jest elementem z innego swiata.</p><p>Mamy wiec baze danych od okreslonego dostawcy, ktora ma sie nijak do jezyka programowania, ktory uzywamy w naszej
logice biznesowej.</p><p>Nasze aplikacje ma eksponuje swoje API czy GUI niekoniecznie w tym samym jezyku co logika biznesowa.</p><p>Oczywiscie takie zroznicowanie jest niezwykle rzadkie i w wiekszosci wypadkow technologie sa do siebie dostosowane.</p><p>Malo tego ...</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/03.Monolith_modules.png"></img><div class="notes"><p>... wewnetrznie kazdy element moze byc perfekcyjnie zoorganizowanym organizmem.</p><p>Kazdy modul ma wyodrebnione wlasne zadanie i wspolpracuja razem w celu osiagniacie wspolnego celu.</p><p>W koncu Uncle Bob nie napisal ksiazki na darmo i wszyscy produkujemy tylko czysty kod.</p><p>Gdzie lezy wiec problem.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/04.Monolith_small_team.png"></img><div class="notes"><p>Gdzie pewnie w kamieniu jest wypisane, ze na poczatku byl monolit.</p><p>Na poczatku twoja zespol liczy pewnie 5, gora 10 osob. Ustalenie jakiejkolwiek sprawy zajmuje 5 minut, bo kolega
siedzi obok na krzesle. Rzucasz haslo, problem rozwiazany.</p><p>Jesli twoja firma odniesie sukces wielce prawdopodne jest to, ze twoj zespol sie powiekszy.</p><p>Nieunikniony stanie sie podzial na mniejsze zespoly i mamy taka sytuacje...</p></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/05.Monolith_multiple_teams.png"></img><div class="notes"><p>... kazdy zespol musi dokonac zmiany w tym samym module zeby rozwiac zupelnie inne rozwiazanie.</p><p>Kazdy walczy o dostep do tego samego moduly, zmiany zachodza na siebie. Teraz musimy ustalac kolejnosc, kto i na
jakich zasadach ma dostep do kodu.</p><p>Wszelki decyzje wymagaja koordynacji miedzy zespolami, a czas od wprowadzenia</p><p>Trzeba tez ustalic kto i w jaki sposob...</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/06.Monolith_continuous_deployment.png"></img><div class="notes"><p>..wrzuca zmiany na produkcje. I wreszcie kto jest odpowiedzialny jak cos pojdzie nie tak.</p><p>Ktora zmiana zepsula testy jednostkowe, a ktora zmiana zmienila wyniki testow integracyjnych.</p><p>Monolit nie ulatwia zycia duzym zespolom. Ktos ma takie doswiadczenia? :)</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/07.Monolith_generic_library.png"></img><div class="notes"><p>W monolitycznej aplikacji trzeba tez uwazac jaki wplyw na dzialanie innych modulow bedzie miala kazda zmiana.</p><p>Jako programisci lubimy tworzyc wielkie generyczne biblioteki, ktore "ulatwiaja nam zycie".
Przewaznie laduje to w module UTILS. <strong>Kto nie popelnil tego grzechu niech podniesie reke</strong></p><p>Problem w monolitycznej generycznej biblioteki lezy w jej uniwersalnosci. Jesli jest ona generyczna to musi
wykonywac rozne zadania w roznym kontekscie.</p><p>Jak zobacze kod, ktory produkuje dane, z ktorych nie korzystam to powinienem je usunac.
ALEEEE....
Ten sam kod jest uzywany przez zespol z drugiego konca biura albo swiata i musze pozostawic ten nic nie znaczacy kod
dla innych.</p><p>Usuwanie duplikacji nie zawsze przynosi zamierzone korzysci.</p><p>To jest wlasnie powod dlaczego tak trudno jest pisac biblioteki ogolnego zastosowania.</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/08.Monolith_technology.png"></img><div class="notes"><p>Inny problem. Jak juz mowile to raczej rzadki przypadek kiedy aplikacja w architekturze monolityczne nie jest
monolityczna na poziomie technologicznym.</p><p>Jako ze technologia uzyta w projekcie jest juz sprawdzona zespoly stosuja ja bezwiednie aby uniknac
ewentualnych problem przy wdrozeniu.</p><p>Jesli uzywam mlotka wszystko wyglada jak gwozdzie. Takie podejscie nie pozwala na zastosowanie technologi odpowiednie
do klasy problemu. Java przykladowo nie jest dobry rozwiazaniem jesli chodzi o BigData.
Apache Spark z kolei nie jest dobrym rozwiazaniem do pisania aplikacji typu CRUD.</p><p>Powiazanie technologiczne z kolei czesto prowadzi do nastepnego problemu.
Jesli przykladowo nasza aplikacja jest aplikacja internetowa i wybor nasz padl na Jave to wszystko mamy
upakowane jako piekny, ogromny WAR.</p><p>Aplikacja zawiera wszystkie potrzebne moduly i kazdorazowo wymaga wrzucenia wszystkich elementow.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/09.Monolith_scale.png"></img><div class="notes"><p>Teraz wyobrazmy sobie, ze obciazenie naszej aplikacji ze strony nasze strony www wzrasta. Aby zapobiec problemom
dostawiamy sobie nastepny serwer i wrzucamy nasza aplikacje.</p><p>Dziala?!! Dziala.</p><p>Moment, moment. Nasza aplikacja jest obciazana jedynie po stronie internetowej. Nasze API nie wymaga skalowania.
Zmarnowalismy wlasnie kawal zasobow w naszej chmurze i placimy za element, ktory nie jest kompletnie potrzebny.</p></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/10.Monolith_scale_more.png"></img><div class="notes"><p>Ok. Jest przeciez alternatywa mozemy na tej samej maszynie postawic jeszcze raz ten sam monolit.
W ten sposob nie zmarnujemy cennego miejsca na naszej maszynie.</p><p>Tylko, ze w tym momencie wrzucilismy programistow na problemy z konfiguracja. Chcialbym odzyskac wszystkie godziny
spedzone na konfigurowaniu aplikacji dla roznych srodowisk. Pewnie uzbieraloby sie tego na porzadne wakacje.</p><p>Tym razem takze marnujemy nasze cenne zasoby tylko, ze w inny sposob. Teraz marnujemy je na jednej maszynie nie
uzywajac naszego API w niewielkim stopniu.</p><p>I tutaj do gry wchodzi...</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/00.good.jpg" class="good-bad-ugly black-border"></img><div class="notes"><p>Dobry.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/11.Microservice_first_steps.png"></img><div class="notes"><p>Gdyby tak podzielic nasz monolit na male kawalki, gdzie kazdy z elementow bedzie odpowiedzialny za inny wycinek
logiki biznesowej.</p><p>Oto podstawa architektury mikroserwisow. Dziel i rzadz. Nasza aplikacja jest teraz zespolem serwisow,
ktory tworzy jedna aplikacje.</p><p>Jesli stwierdzimy ze mamy zamiar zmienic modul odpowiedzialny za API nie musimy juz nikogo pytac. Wprowadzamy nowa
technologie, usuwamy nadmiarowy kod niezaleznie od innych serwisow.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/12.Microservice_independence.png"></img><div class="notes"><p>I tutaj warto wspomniec o jednej z najwiekszych zalet tego typu architektury.</p><p>Kazdy serwis moze byc kompletnie niezalezny technologicznie. Jesli zespol preferuje Java nic nie stoi na przeszkodzie
aby zaimplementowac serwis w Javie. To wlasny wybor tego zespolu:)</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/13.Microservice_independence_db.png"></img><div class="notes"><p>Niezaleznosc technologiczna rozciaga sie tez na bazy danych. Nie musimy juz wspoldzielic danych z innymi.
Mikroserwis jest odpowiedzialny za logike, a wiec w konsekwencji tez za dane, ktorymi zarzadza.</p><p>Niezaleznosc technologiczna pozwala nam na jeszcze jedna rzecz. Zmiane organizacji zespolow.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/14.Microservice_independence_teams.png"></img><div class="notes"><p>Jesli mamy niezalezne serwisy to mozemy wokol nich zoorganizowac niezalezne zespoly. Pozwala sie to skupic na
konretnym problemie, ktory dany serwis rozwiazuje.</p><p>Nieoczekiwana zaleta takiego rozwiazania jest mozliwosc przejscia do zespolu, ktory implementuje cos innego niz
Encje JEE w Hibernacie. Jesli czujesz sie znudzony zmieniasz zespol nie prace.</p><p>Zeby w pelni wykorzystac ta zalete niezaleznosci trzeba wyksztalcic inna kulture pracy. Kulture pracy, w ktorej
jestesmy odpowiedzialni nie tylko za swoj serwis, ale odpowiadamy za wszystkie razem. Nie tylko jako zespol, ale
jako cala firma. Tylko wtedy zmiany w zespolach beda traktowane jak czesc procesu doskonalenia aplikacji.</p><p>Niezalezny zespol plus niezalezny serwis oznacza niezalezny deployment.</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/15.Microservice_deployment.png"></img><div class="notes"><p>Teraz zespol decyduje kiedy i jak dany serwis trafia na produkcje. Caly przeplyw od wrzucenia kodu
do pojewienia sie na produkcji jest w pelni pod kontrola tylko jednego zespolu.</p><p>Jesli masz krytycznego bug'a nie boisz sie go wrzucic. Nie czekasz w nieskonczonosc na inne zespoly. Ty jestes u steru.</p><p>Dobrze. Aplikacja podzielona i wrzucona na produkcje ale teraz musimy odpowiedziec sobie jak te serwisy komunikuja sie.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/16.Microservice_communication.png"></img><div class="notes"><p>Teraz czesci skladowe aplikacji nie egzystuja w jednym miejscu. Niezaleznosc technologiczna wymusza nowe sposoby
komunikacji na kazdym z serwisow.</p><p>Aby zrozumiec sie nawzajem konieczny jest sposob, ktory bedzie zrozumialy dla obydwu stron. Jaki wiec protokol
trzeba zastosowac zeby byl zrozumialy dla kazdego jezyka. Oczywiscie HTTP.
Protokol HTTP jest protokolem podstawowym dla prawie kazdego jezyka. Jesli jego nadinterpretacja prawie niemozliwa
stal sie on naturalnym kandydatem.</p><p>Z tego samego powodu popularnosc zdobyl JSON jako formatu danych. Poprzez protokol HTTP slemy JSON/XML. Kazdy jest
w stanie bez przeszkod skomunikowac sie i zinterpretowac przekazane dane.</p><p>Ok. Sprawa komunikacji zalatwiona. Teraz mozemy ukladac nasze serwisy jak puzzle.</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/17.Microservice_scale.png"></img><div class="notes"><p>Skalowanie nie jest problemem. Kazdy serwis jest na tyle maly, ze skalujemy znowu NIEZALEZNIE od innych.</p><p>Jesli teraz konieczne jest obsluzenie wiekszej ilosci zgloszen w jednej czesci systemu, skalujemy tylko ta czesc.</p><p>Jako ze jestesmy mniejsi mozemy uruchomic sie wielokrotnie na jednej maszynie.
Teraz wykorzystanie naszych zasobow jest bardziej optymalne.</p><p>Ktos pewnie teraz powie "Zaraz, zaraz. Przeciez kazdy serwis ma jakis stan. W jaki sposob ten stan jest dzielony".
Otoz mikroserwisy nie powinny posiadac stanu. Bezstanowosc nie oznacza, ze nie mamy danych. Mamy ale powinny byc one
dostepne w bazie danych, ktora jest zrodlem. Nie jest to twardy wymog, ale powoduje mniej problemow.</p><p>Mamy aplikacje podzielona, rozrzucona po calej infrastrukturze, komunikujaca sie ze soba bez przeszkod.
Tylko skad ja wiem czy to dziala i czy dziala dobrze.</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/18.Microservice_monitoring.png"></img><div class="notes"><p>Monitoring. Monitoring. I jeszcze raz monitoring.</p><p>Powtorze to co mowia osoby, ktore wdrazaja mikroserwisy:</p><p>"Jesli cos sie rusza zrob z tego wykres, graf".
"Jesli cos sie nie rusza zrob z tego wykres, graf. Moze zrobilo sobie przerwe."</p><p>Nasza aplikacja jest teraz systemem rozproszonym z niejednolitymi technologiami. Bez wiedzy na temat CO i JAK sie
porusza w systemie jestesmy slepi.</p><p>Co konkretnie wiec mamy monitorowac. Rzeczy podstawowe jak obciazenie procesora, ilosc dysku na
maszynie, wszystko co dzieje sie na konkretnej maszynie,</p><p>stan serwisow, stan narzedzi wspierajacych , logi serwisow,  ilosc danych wysylanych z/do sieci.</p><p>WSZYSTKO. DOSLOWNIE WSZYSTKO.</p><p>Samo zbieranie to nie wszystko. Dane zbieramy i aktywnie analizujemy. Po co analizujemy. Po to by miec
Automatyczny System Wczesnego Ostrzegania o problemach zanim zabija nasz system.</p><p>Automatyczny System Wczesnego Ostrzegania daje nam jeszcze nieoceniona mozliwosc. Mozliwosc stworzenia systemu
AUTOMATYCZNEGO NAPRAWIANIA problemu. Jesli monitorujemy tak wiele elementow i przygotujemy odpowiednie wizualizacje na
80% znajdziemy jakies wzory. Nasze mozgi sa do tego przygotowane od poczatku istnienia ludzkosci.
Jesli mamy wzor problemu to mozemy wykonac pewne operacje bez ingerencji czlowieka.</p><p>Koniec z telefonami o 3ej nad ranem i wyrywanie czlowieka ze srodka urlopu. Po to dzielismy aplikacje, aby teraz
nasza reakcja bylo ukierunkowana na odpowiedni cel. Nie na caly system.</p><p>Mysle ze z grubsza zdefiniowalismy glowne cechy architektury mikroserwisow. Czas na...</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/00.bad.png" class="good-bad-ugly black-border"></img><div class="notes"><p>ZLEGO.
Zadne rozwiaznie jest srebrna kula, ktora rozwiaze wszystkie twoje problemy.
Co wiec poswiecilismy na oltarzu nowoczesnoci.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/19.Microservice_test.png"></img><div class="notes"><p>Testowalnosc. Pierwsza ofiara mikroserwisow. W przypadku monolitycznej aplikacji pokrycie kodu testami jednostkowymi
dawalo na duza pewnosc, ze aplikacja bedzie dzialac poprawnie.</p><p>Nadal to jest prawda ale dziala to niestety tylko w skali micro. Jesli serwisy byly wczesniej modulami jak teraz
mam testowac wspoldzialanie miedzy modulami.</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/20.Microservice_test_Contract.png"></img><div class="notes"><p>Musimy stworzyc dodatkowy twor pozwalajacy nam na harmonijna wspoprace miedzy serwisami.</p><p>Tym tworem jest kontrakt. Umowa potwierdzajaca sposob komunikacji miedzy serwisami.
Kazda zmiana w danych wyjsciowych powinna zostac umieszczona i przetestowana wzgledem kontraktu.</p><p>Zmiany w kontrakcie nie mozna sobie dodac "O! Tak!". Konieczna jest akceptacja umowy ze strony konsumentow.
Stad nazwa Consumer Driven Contract - Kontrakt prowadzony przez konsumenta.</p><p>Cala niezaleznosc poszla do kosza. Teraz nie moge zlamac testow kontraktowych, a jesli bede chcial zlamac sposob
komunikacji to bede musial sie zmierzyc z silami innych serwisow - zespolem odpowiedzialnym za konsumpcje moich danych.</p><p>Tutaj wraca stary temat kultury pracy. W tym miejscu szczegolnie wazne jest poczucie wspoldzialania w ramach produktu,
jakim jest cala aplikacja, a nie myslenia tylko o swoim serwisie.
Konflikty sa nieuniknione, ale wazne jest jak je rozwiazujemy, a nie jak ich unikamy.</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/21.Microservice_test_E2E.png" class="big-picture"></img><div class="notes"><p>Ktos pewnie podpowie wam, ze mozna wprowadzic testy calego systemu. Uruchomimy sobie srodowisko testowe, staging czy
cos podobnego i tam w warunkach zblizonych do produkcyjnych potestujemy cala aplikacje.</p><p>Unikajcie tych testow jak ognia. Cale zlo w firmach lezy w testach E2E. 2 lata temu mialem okazje ugrzeznac w takich
testach. Koszmary mam do dzisiaj.</p><p>Dlaczego zalecam to unikac:</p><ol><li>Jak bardzo twoje srodowisko jest podobne do produkcyjnego. Czy mozesz polegac na tej konfiguracji?</li><li>Ile to bedzie kosztowac? To juz problem twojego manager.</li></ol><p>3. Kto jest winny kiedy test pojdzie nie tak. Przy odrobinie szczescia mamy dobry monitoring i mozemy przesledzic
sciezke problemu. Tylko ile czasu nam to zajmie zeby to ustalic.</p><ol><li>Jak zmierzyc pokrycie? Czy jest jakis element w systemie, ktory moze polozyc cala aplikacje?</li></ol><p>Nie mowie, ze takich testow nie nalezy pisac. Zeby tylko nikomu nie wydawalo sie ze wielkosc trapezu na slajdzie
oznacza ilosc testow.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/22.Microservice_test_triangle.png"></img><div class="notes"><p>Piramidka testow musi byc zachowana. Jak najwiecej jednostkowych testow. Troche mniej kontrakto-integracyjnych.
W koncu jak najmniej E2E. Zostawiamy sobie jeszcze miejsce na losowe klikanie po aplikacji.</p><p>Co jeszcze moze pojsc nie tak?</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/23.Microservice_network_issue.png"></img><div class="notes"><p>Rozproszonosc systemu moze byc zaleta i wada.</p><p>Zeby zobrazowac problemy posilimy sie czyjas madroscia.
Kilku ludzi w Sun Microsystems na podstawie eksperymentow wyodebrnili 8 mitow dotyczacych systemow rozproszonych.
Trzy z nich dotykaja mikroserwisy szczegolnie.
Sa to:</p><ol><li>The network is reliable. Siec jest niezawodna</li><li>Latency is zero. Opoznienie jest zerowe.</li><li>Bandwidth is infinite. Przepustowosc jest niegraniczona.</li></ol><p>Te trzy wybrane mity mowia nam jak duzo rzeczy zakladamy piszac nasz kod i jak bardzo sie mylimy.
Dlatego niezwykle istotne jest aby nasze serwisy byly odporne na tego typu problemy.</p><p>Jesli siec przestanie dzialac lub odpowiedzi z innego serwisu nie bede naplywaly w odpowiednim tempie, musimy
przewidziec taka sytuacje i byc gotowi dzialac dalaja ale w stanie wyjatkowym.</p><p>Musimy byc tez gotowi na powrot do stanu normalnego. Wyrzucenie RuntimeException nie wchodzi juz w gre.
Usmiercanie serwisu przy byle okazji nie jest naszym celem.</p><p>Wszelkie stany wyjatkowe pojawiajace sie w serwisie powinny byc monitorowane. Monitorowanie daje nam mozliwosc
sprawdzenia glownej przyczyny i reakcje zanim problem zabije wszystkie nasze serwisy.</p></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><img src="images/slides/24.Microservice_independence_issue.png"></img><div class="notes"><p>Niezaleznosc technologiczna tez moze okazac sie przeklenstwem.</p><p>Wyobrazmy sobie sytacje, gdy kazdy z serwisow musi rozwiazac identyczny problem, czy to technologiczny, czy biznesowy.
W monolitycznej aplikacji rozwiazaniem byloby stworznie odzielnego modulu, ktory bedzie odpowiadal za rozwiazanie
tego problemu.</p><p>Kazdy z serwisow musi rozwiazac ten problem w obrebie swojego wlasnego stosu technologicznego. Dzielenie sie biblioteka
napisana w Ruby z Java jest pewnie ekstremalnie trudne i rownie ekstremalnie glupie.</p><p>W praktycy jesli mamy problem do rozwiazania, ktory dotyka prawie wszystkich serwisow, z automatu problem
przeksztalca sie w nowy kontekst dzialania naszej aplikacji. Wymaga on modelowania, a co za tym idzie nowego serwisu.</p><p>Problem nie zawsze jest jedna wystarczajaco duzy, zeby pojsc ta sciezka. Jesli bedziemy tworzyc zbyt duzo serwisow,
istnieje ryzyko zabicia systemu poprzez pikowanie. Pikoserwis tam, pikoserwis tutaj, pikoserwisy wszedzie.
Pikoserwisy doprowadza cie do szalenstwa swoim niewielkim rozmiarem i zlozonoscia srodowiska, w ktorym przyjdzie im
zyc.</p><p>Wystarczy tej wycieczki po czubku gory lodowej.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="mikroserwisy">Mikroserwisy</h1><div class="notes"><p>Czym wiec sa wiec Microserwisy?</p><p>Czy jest to Metodyka? W pewnym sensie jest to jaka&#x15B; standaryzacja podej&#x15B;cia do problemu.</p><p>Czy jest to Architektura? W pewnym sensie jest to spos&#xF3;b na organizacje oprogramowania.</p><p>Wszyscy szukamy &#x15B;cis&#x142;ej definicji i jest o nia niezwykle trudno. Zapewnie wiele firm b&#x119;dzie was przekonywa&#x107;,
&#x17C;e to jest Spring Boot albo jakis inne oprogramowanie. Nie sluchajcie ich.</p><p>Niektorzy beda was przekonywac, ze zmiana na Mikroserwisy naprawi wasze problem biznesowe i technologiczne.
Nie sluchajcie ich.</p><p>vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</p><p>Mikroserwisy to sposob myslenia o aplikacji w sposob calosciowy poczawszy
od <strong>sposobu organizacji kodu</strong> poprzez <strong>infrastrukture</strong>
po <strong>organizacje twojego zespolu</strong>.</p><p>Dziekuje. Mama nadzieje ze nie zanudzilem na smierc. Pytania ?</p></div></div><div class="step step-level-1" step="30" id="questions" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="id1">???</h1><div class="notes"><p>Pytania</p></div></div></div><div id="hovercraft-help" class="hide"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>